use clap::ValueEnum;
use opentelemetry_otlp::{
    OTEL_EXPORTER_OTLP_ENDPOINT, OTEL_EXPORTER_OTLP_METRICS_ENDPOINT,
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT,
};
use opentelemetry_sdk::trace::{RandomIdGenerator, Sampler};
use sentry_tracing::{event_from_event, EventMapping};
use serde::{Deserialize, Serialize};
use std::{borrow::Cow, fmt};
use tracing::field::Visit;
use tracing_subscriber::{filter::FilterFn, layer::SubscriberExt, Layer};

#[derive(
    ValueEnum, Default, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Deserialize, Serialize,
)]
#[clap(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum LogLevel {
    Trace,
    Debug,
    #[default]
    Info,
    Warn,
    Error,
}

impl fmt::Display for LogLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                LogLevel::Trace => "trace",
                LogLevel::Debug => "debug",
                LogLevel::Info => "info",
                LogLevel::Warn => "warn",
                LogLevel::Error => "error",
            }
        )
    }
}

#[derive(
    ValueEnum, Default, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Deserialize, Serialize,
)]
#[clap(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum LogFormat {
    #[default]
    Pretty,
    Json,
    StackDriver,
    Minimal,
}

// for filtering out specific events in the `sentry_tracing` layer
#[derive(Debug)]
struct SentryEventVisitor {
    // for the extra event generated by sentry_tracing
    filter_from_sentry: bool,
    // injected in the middleware
    is_request_error: bool,
}

impl Visit for SentryEventVisitor {
    fn record_debug(&mut self, field: &tracing::field::Field, value: &dyn std::fmt::Debug) {
        if field.name() == "error" {
            self.record_str(field, &format!("{value:?}"));
        }
    }

    fn record_str(&mut self, field: &tracing::field::Field, value: &str) {
        if field.name() == "error" && (value.contains("bad-request") || value.contains("internal"))
        {
            self.filter_from_sentry = true;
        }
    }

    fn record_bool(&mut self, field: &tracing::field::Field, value: bool) {
        if field.name() == "is_request_error" {
            self.is_request_error = value;
        }
    }
}

#[must_use = "make sure the sentry guard is not dropped immediately"]
pub fn setup_tracing(
    modules: &[&str],
    log_level: &LogLevel,
    log_format: &LogFormat,
    sentry_dsn: Option<String>,
    env_name: String,
) -> eyre::Result<Option<sentry::ClientInitGuard>> {
    // common filter - show only `warn` and above for external crates.
    let mut filter = tracing_subscriber::EnvFilter::builder()
        .with_default_directive("warn".parse()?)
        .from_env()?;

    for proj_crate in modules {
        filter = filter.add_directive(format!("{proj_crate}={log_level}").parse()?);
    }

    let use_otel_tracing = std::env::var(OTEL_EXPORTER_OTLP_ENDPOINT).is_ok()
        || std::env::var(OTEL_EXPORTER_OTLP_TRACES_ENDPOINT).is_ok();
    let telemetry = if use_otel_tracing {
        let trace_config = opentelemetry_sdk::trace::config()
            .with_sampler(Sampler::AlwaysOn)
            .with_id_generator(RandomIdGenerator::default());

        let tracer = opentelemetry_otlp::new_pipeline()
            .tracing()
            .with_exporter(opentelemetry_otlp::new_exporter().tonic())
            .with_trace_config(trace_config)
            .install_batch(opentelemetry_sdk::runtime::Tokio)?;

        Some(
            tracing_opentelemetry::layer()
                .with_location(true)
                .with_threads(true)
                .with_tracked_inactivity(true)
                .with_tracer(tracer),
        )
    } else {
        None
    };

    let use_otel_metrics = std::env::var(OTEL_EXPORTER_OTLP_ENDPOINT).is_ok()
        || std::env::var(OTEL_EXPORTER_OTLP_METRICS_ENDPOINT).is_ok();
    let metrics = if use_otel_metrics {
        let meter_provider = opentelemetry_otlp::new_pipeline()
            .metrics(opentelemetry_sdk::runtime::Tokio)
            .with_exporter(opentelemetry_otlp::new_exporter().tonic())
            .build()?;

        opentelemetry::global::set_meter_provider(meter_provider.clone());
        Some(tracing_opentelemetry::MetricsLayer::new(meter_provider))
    } else {
        None
    };

    let sentry_layer = sentry_tracing::layer().event_mapper(|evt, ctx| {
        let mut sentry_visitor = SentryEventVisitor {
            filter_from_sentry: false,
            is_request_error: false,
        };
        evt.record(&mut sentry_visitor);

        // avoid sending duplicate event to Sentry, or sending any events in case of
        // 4XX errors
        if sentry_visitor.is_request_error || sentry_visitor.filter_from_sentry {
            return EventMapping::Ignore;
        }

        // filter out non-errors
        if evt.metadata().level() != &tracing::Level::ERROR {
            EventMapping::Ignore
        } else {
            // send the original `sentry` event unchanged
            EventMapping::Event(event_from_event(evt, ctx))
        }
    });

    let layer = tracing_subscriber::registry()
        .with(telemetry)
        .with(metrics)
        .with(filter)
        .with(sentry_layer);

    // Hides spans and empty message events/logs
    let log_filter =
        FilterFn::new(|meta| !meta.is_span() && meta.fields().field("message").is_some());

    match log_format {
        LogFormat::Pretty => {
            let stdout_trace_layer = tracing_subscriber::fmt::layer().with_filter(log_filter);

            tracing::subscriber::set_global_default(layer.with(stdout_trace_layer))?;
        }

        LogFormat::Json => {
            let stdout_trace_layer = tracing_subscriber::fmt::layer()
                .json()
                .with_span_list(false)
                .with_current_span(false);

            tracing::subscriber::set_global_default(layer.with(stdout_trace_layer))?;
        }

        LogFormat::StackDriver => {
            // This outputs to stdout for now, but integration with Google Cloud's logging suite will need to be done.
            // Also potentially use OpenTelemetry instead with an exporter for StackDriver traces.
            let stackdriver_layer = tracing_stackdriver::layer().with_filter(log_filter);

            let subscriber = layer.with(stackdriver_layer);

            tracing::subscriber::set_global_default(subscriber)?;
        }

        LogFormat::Minimal => {
            let stdout_trace_layer = tracing_subscriber::fmt::layer()
                .without_time()
                .compact()
                .with_target(false)
                .with_filter(log_filter);

            tracing::subscriber::set_global_default(layer.with(stdout_trace_layer))?;
        }
    }

    let sentry_guard = (env_name != "dev")
        .then(|| {
            sentry_dsn.map(|dsn| {
                sentry::init((
                    dsn,
                    sentry::ClientOptions {
                        release: sentry::release_name!(),
                        environment: Some(Cow::Owned(env_name)),
                        ..Default::default()
                    },
                ))
            })
        })
        .flatten();

    Ok(sentry_guard)
}

pub fn meter(name: &'static str) -> opentelemetry::metrics::Meter {
    opentelemetry::global::meter(name)
}
